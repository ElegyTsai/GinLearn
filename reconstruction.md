# 重构
## 1-一个案例
- 重构第一步都是要为即将修改的代码建立一组可靠的测试环境
1. 重构都是逐步逐步进行，首先就是分解，将复杂的代码进行封装，
2. 更改变量名称是值得的行为，好的代码应该清晰表达出功能，而变量名称也是其中的关键
3. 明确每个方法和函数所属的对象
4. 尽量除去一些临时变量，临时变量往往引发问题，他们会导致大量参数传来传去，甚至要付出性能上的代价
5. 可以利用多态来取代switch
6. 运用状态模式来动态地修改自己的分类，从而实现多态 （回忆state模式，把自己的行为委托给一个状态类完成，通过修改状态来实现动态调整自己的分类
7. 用抽象类+继承类的方式实现state/strategy模式

## 2-重构原则
### 何谓重构 为何重构
重构：对软件内部建构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。   
- 重构改进软件设计。经常性的重构可以帮助代码维持自己该有的形态   
- 重构使软件更容易理解。 让未来出现的开发者容易理解和优化表达
- 重构找到bug。 对代码重构可以深入理解代码的行为，找出bug
- 重构提高变成速度。 重构帮助我们更快速地开发程序。
### 何时重构
- ***三次法则***：事不过三，三则重构
- 添加功能时重构
- 修补错误时重构
- 复审代码时重构
### 重构的难题
- 数据库是比较难以修改的。必须很小心的把数据库结构和对象模型见的依赖降至最低。其中比较好的方式就是在之间插入一个分隔层，隔离两个模型各自的变化。
- 修改接口是比较困难的事情，因为必须同时维护两个接口，直到所有用户都有时间对这些变化作出反应。
- 难以通过重构手法完成的设计改动
何时不该重构？
- 重构（refactoring)

## 3-代码的坏味道
1. 重复代码
如果互为兄弟的子类内含相同表达式。
2. 过长的函数
太长就表示没有好好的分解。
***原则***：每当感觉需要用到注释的时候，就可以提炼成一个新的函数。
提炼函数的时候有很多临时变量，会导致可读性没有提升。
3. 过大的类
把太多的实例变量提炼至新的类内
4. 过长的参数列
太多的参数不如用对象去传递
5. 发散式变化
6. 霰弹式修改
7. 依恋情节
8. 数据泥团
9. 基本类型偏执
10. switch语句
11. 平行继承类
12. 冗赘类
13. 夸夸其谈未来性
14. 令人迷惑的暂时字段
15. 过度耦合的小洗脸
16. 中间人
过度的委托人会变得麻烦
17. 狎昵关系
对彼此private的成分太过探究
18. 异曲同工的类
19. 不完美的类库
20. 纯稚的数据类
21. 被拒绝的遗赠
子类不想要或不需要的继承，意味着继承体系设计错误。可以新建一个兄弟类。但这个不一定是坏事      
但是如果子类复用了超类的行为，却又不愿意支持超类的接口说明这是一个坏代码
22. 过多的注释

## 4-构筑测试体系
最好是在开始编程之前，需要添加特性的时候，先写相应的测试代码

## 5-重构列表
## 6-重新组织函数
常见手法
- 对函数进行整理，处理局部变量
- 提炼函数
将一段代码放进一个独立函数中，并让函数名称解释该函数的用途
需要修改临时边的提炼函数，可以用返回值重新赋值。多个临时变量不推荐这样
- 内联函数
在函数调用点插入函数本体，就是提炼函数的反向操作
- 内联临时变量：一遍赋值的临时变量直接用表达式代替
- 以查询取代临时变量
把脸是变量保存某一表达式的运算结果
- 引入解释性变量：把复杂表达式或是其中一部分的结果放进一个临时变量，用变量名称来解释表达式用途
- 分解临时变量： 针对每次赋值，创造一个独立，对应的临时变量
- 移除对参数的赋值：以一个临时变量取代该参数的位置，不对参数赋值是一个好习惯（用于长函数的final
- 以函数对象取代函数：把整个函数放进一个对象中，局部变量就成了对象内的字段，就可以在同一个对象中不断分解
- 替换算法：用一些简单的算法

## 7-在对象之间搬移特性
- 搬迁函数：把一个函数移到另一个对象中
- 搬迁字段：把变量的特性进行搬迁
- 提炼类：建立新类，将相关的字段和函数从旧类搬迁到新类
- 将类内联化：提炼类的反向
- 隐藏委托关系：在服务类上建立客户所需的所有函数，以此隐藏委托关系
- 移除中间人：做了太多委托，所以移除一部分
- 引入外加函数：在客户类中建立以个函数，用第一参数的形势传入以个服务器类（这个没什么用限制很大
- 引入本地扩展：建立一个新类，使其包含这些额外函数。 有两种方式，子类或者包装类，通常选择子类。
子类即直接继承父类，而包装类则是把之前的类作为一个成员，重新书写。

## 8-重新组织数据
拒绝魔术，用变量代替
- 自封装字段：为这个字段建立取值/设置函数，并且只能以这些函数来访问字段
- 以对象取代数据值：把数据项变成对象
- 把值对象改为引用对象
- 以对象取代数组
- 赋值被监视的数据（观察者模式？
- 将单向关联改为双向关联：添加一个反向指针，使修改函数能够同时更新两条连接（代价是效率，以及僵尸对象
- 将双向关联改为单向关联：单方面的关联。
- 以字面常量取代魔法数
- 封装字段：将其申明为private，并提供相应的访问函数
- 封装集合：返回该集合的一个只读副本，并在这个类中提供添加和移除集合元素的功能
- 以数据类取代记录：为该记录添加一个哑数据
- 以类取代数据码
- 以子类取代数据码
- 以state/strategy取代数据码
- 以字段取代类

## 9-简化条件表达
大量的条件表达式会降低代码的可读性，所以用多态来实现代码的可读性和简化条件是常见思路
- 分解条件表达式：把条件分解成一个函数 if(notSomething)
- 合并条件表达式：目的是简化条件
- 合并重复的条件表达式：在两个if内都有的事情可以移到if外执行
- 移除控制标记：对于控制语句。最好直接用break或者continue来实现
- 以卫语句取代嵌套表达式：卫语句就是如果为真直接返回的
- 将条件反转：把条件表达式变得更简单
- 以多态取代表达式：switch type 可以用多态覆写来实现
- 引入null对象：将null值改为null对象（null对象最好是单例）  很多时候为们需要判断是否为null，但是可以直接引入一个空对象然后覆写它的行为，来让这些空对象也实现类似对象的工作，不用单独判断
- 引入断言

## 10-简化函数调用
- 一个好的函数名称
- 添加参数，移除参数
- 将查询函数和修改函数分离（考虑并发问题）
- 新建一个带参数的函数，用来完成若干个重复函数
- 以明确函数替代参数：对每个参数建立一个函数
- 保持对象的完整：取出对象的若干值，不如直接把整个对象传递过去
- 以函数取代参数，如果需要上一个函数的结果作为参数的话，不如想办法用函数取代掉参数，减少调用参数个数
- 引入参数对象：如果有很多个参数的话用一个对象实现包装
- 移除设置函数：不需要改变的值就不要有设值函数
- 隐藏函数：不被用到的函数设值成private
- 用工厂函数替代构造函数：工厂模式的运用
- 封装向下转型：但是向下转型这个行为必须少做
- 用异常替代错误码
- 以测试替代异常

## 11-处理概括函数
- 字段上移：把几种子类共有的字段移到超类中
- 函数上移
- 构造函数上移
- 字段下移
- 函数下移
- 提炼子类
- 提炼超类
- 提炼接口
- 折叠继承关系
- 塑造模板函数
- 以委托替代继承
- 以继承替代委托：评价的标准是子类有没有用上父类的全部接口方法

## 12-大型重构
- 梳理并分解继承体系：建立两个继承体系，并通过委托关系，让其中一个可以调用另外一个
- 将过程化设计转变成对象化设计
- 将领域和表达/显示分离
- 提炼继承体系
- 